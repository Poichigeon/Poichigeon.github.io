{"meta":{"title":"遇事不决，可问春风","subtitle":"","description":"","author":"Poichigeon","url":"https://Poichigeon.github.io","root":"/"},"pages":[{"title":"Guestbook","date":"2021-03-07T07:00:00.000Z","updated":"2021-03-10T07:20:47.237Z","comments":true,"path":"guestbook/index.html","permalink":"https://poichigeon.github.io/guestbook/index.html","excerpt":"","text":""},{"title":"Tags","date":"2021-03-10T07:14:49.000Z","updated":"2021-03-10T07:29:20.855Z","comments":false,"path":"tags/index.html","permalink":"https://poichigeon.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"了解ChatGPT：您的智能聊天助手","slug":"how-to-use-chatgpt","date":"2023-04-11T10:00:00.000Z","updated":"2023-04-11T10:00:00.000Z","comments":true,"path":"2023/04/11/how-to-use-chatgpt/","link":"","permalink":"https://poichigeon.github.io/2023/04/11/how-to-use-chatgpt/","excerpt":"在这篇文章中，我们将介绍ChatGPT，一个基于OpenAI的GPT-4架构的强大聊天机器人，以及如何使用它来提高您的工作效率和娱乐体验。","text":"在这篇文章中，我们将介绍ChatGPT，一个基于OpenAI的GPT-4架构的强大聊天机器人，以及如何使用它来提高您的工作效率和娱乐体验。 ¶什么是ChatGPT？ ChatGPT是一种基于OpenAI的GPT-4架构的大型语言模型。它被训练成可以理解和生成自然语言，为用户提供高质量、有趣和实用的对话。ChatGPT能够提供各种应用，包括问答、写作辅助、编程帮助和众多其他领域。 ¶如何使用ChatGPT？ 要开始与ChatGPT互动，您可以选择以下方法之一： 在线平台：访问OpenAI官方网站，注册账户并开始与ChatGPT进行聊天。 API：开发者可以通过OpenAI API直接集成ChatGPT到自己的应用、网站或服务中。 无论您选择哪种方式，都可以通过输入自然语言的形式与ChatGPT进行互动。根据您的问题或需求，ChatGPT将为您提供有关问题的答案、建议或其他相关信息。 ¶ChatGPT的应用场景 ¶1. 问答系统 ChatGPT可以用作智能问答回答系统，回答各种领域的问题。例如，它可以回答历史、科学、数学和其他领域的问题。 ¶2. 写作辅助 ChatGPT可以为您提供写作帮助，包括撰写文章、撰写邮件、创建故事和生成创意文本。 ¶3. 编程帮助 对于编程问题，ChatGPT可以提供代码示例、调试建议和解决方案。 ¶4. 语言翻译 ChatGPT具有强大的翻译功能，能够翻译多种语言，帮助您更好地理解外语内容。 ¶5. 娱乐 ChatGPT还可以为您提供娱乐，如生成笑话、讲故事和模拟角色扮演等。 ¶注意事项 虽然ChatGPT非常强大，但请注意，它可能会产生错误的答案或不准确的建议。在使用ChatGPT时，请确保核实其提供的信息，并在关键决策时谨慎行事。 此外，ChatGPT可能会产生不符合道德、法律或社会规范的内容。OpenAI已经努力对其进行限制，但仍然可能出现这种情况。在使用过程中，请自行判断并遵守相关规定。 ¶结论 ChatGPT是一款具有广泛应用前景的人工智能聊天助手，可以在众多领域提供实际帮助。通过了解其功能和用法，您可以充分利用这一强大工具来提高工作效率、学习新知识或寻找娱乐。 无论您是一个开发者、企业家还是个人用户，ChatGPT都能为您带来前所未有的智能交流体验。但请注意，使用ChatGPT时要确保遵守道德、法律和社会规范，以确保获得最佳效果。 最后，我们期待看到ChatGPT不断完善，为用户提供更多高质量的内容和更广泛的应用。让我们一起探索这个充满无限可能的人工智能世界吧！","categories":[{"name":"技术","slug":"技术","permalink":"https://poichigeon.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"ChatGPT","slug":"ChatGPT","permalink":"https://poichigeon.github.io/tags/ChatGPT/"},{"name":"人工智能","slug":"人工智能","permalink":"https://poichigeon.github.io/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"},{"name":"聊天机器人","slug":"聊天机器人","permalink":"https://poichigeon.github.io/tags/%E8%81%8A%E5%A4%A9%E6%9C%BA%E5%99%A8%E4%BA%BA/"}]},{"title":"纯Java读写注册表","slug":"java-registry","date":"2021-11-03T07:19:21.000Z","updated":"2021-11-03T08:13:53.106Z","comments":true,"path":"2021/11/03/java-registry/","link":"","permalink":"https://poichigeon.github.io/2021/11/03/java-registry/","excerpt":"¶前言 Java读取注册表的方式有很多，比如使用java API【java.util.prefs.Preferences】、使用JNA、使用JRegistry以及使用cmd命令，这些都是常见的操作注册表的方式。各有优缺点，本文不再赘述，本文需要介绍的是另一种，用纯Java代码实现的注册表读写。","text":"¶前言 Java读取注册表的方式有很多，比如使用java API【java.util.prefs.Preferences】、使用JNA、使用JRegistry以及使用cmd命令，这些都是常见的操作注册表的方式。各有优缺点，本文不再赘述，本文需要介绍的是另一种，用纯Java代码实现的注册表读写。 ¶纯Java读写注册表 本人也是在机缘巧合下才发现的这个代码，工作中需要读取注册表中的某个值，使用 java API无法读取对应的目录，而JNA和JRegistry又由于版本问题无法集成到我的代码中，以及我的代码运行的终端甚至无法在cmd中执行注册表命令，一筹莫展之下我发现了这篇文章read/write to Windows Registry using Java。 文章开头就提出了几点要求： ·Can read/write to ANY part of the registry. ·DOES NOT USE JNI. ·DOES NOT USE ANY 3rd PARTY/EXTERNAL APPLICATIONS TO WORK. ·DOES NOT USE THE WINDOWS API (directly) Amazing! 这不正是我需要的吗！然后我就在文章里发现了这段代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;import java.util.HashMap;import java.util.Map;import java.util.ArrayList;import java.util.List;import java.util.StringTokenizer;import java.util.prefs.Preferences;public class WinRegistry &#123; private static final int REG_SUCCESS &#x3D; 0; private static final int REG_NOTFOUND &#x3D; 2; private static final int KEY_READ &#x3D; 0x20019; private static final int REG_ACCESSDENIED &#x3D; 5; private static final int KEY_ALL_ACCESS &#x3D; 0xf003f; public static final int HKEY_CLASSES_ROOT &#x3D; 0x80000000; public static final int HKEY_CURRENT_USER &#x3D; 0x80000001; public static final int HKEY_LOCAL_MACHINE &#x3D; 0x80000002; private static final String CLASSES_ROOT &#x3D; &quot;HKEY_CLASSES_ROOT&quot;; private static final String CURRENT_USER &#x3D; &quot;HKEY_CURRENT_USER&quot;; private static final String LOCAL_MACHINE &#x3D; &quot;HKEY_LOCAL_MACHINE&quot;; private static Preferences userRoot &#x3D; Preferences.userRoot(); private static Preferences systemRoot &#x3D; Preferences.systemRoot(); private static Class&lt;? extends Preferences&gt; userClass &#x3D; userRoot.getClass(); private static Method regOpenKey &#x3D; null; private static Method regCloseKey &#x3D; null; private static Method regQueryValueEx &#x3D; null; private static Method regEnumValue &#x3D; null; private static Method regQueryInfoKey &#x3D; null; private static Method regEnumKeyEx &#x3D; null; private static Method regCreateKeyEx &#x3D; null; private static Method regSetValueEx &#x3D; null; private static Method regDeleteKey &#x3D; null; private static Method regDeleteValue &#x3D; null; static &#123; try &#123; regOpenKey &#x3D; userClass.getDeclaredMethod(&quot;WindowsRegOpenKey&quot;, new Class[] &#123; int.class, byte[].class, int.class &#125;); regOpenKey.setAccessible(true); regCloseKey &#x3D; userClass.getDeclaredMethod(&quot;WindowsRegCloseKey&quot;, new Class[] &#123; int.class &#125;); regCloseKey.setAccessible(true); regQueryValueEx &#x3D; userClass.getDeclaredMethod( &quot;WindowsRegQueryValueEx&quot;, new Class[] &#123; int.class, byte[].class &#125;); regQueryValueEx.setAccessible(true); regEnumValue &#x3D; userClass.getDeclaredMethod(&quot;WindowsRegEnumValue&quot;, new Class[] &#123; int.class, int.class, int.class &#125;); regEnumValue.setAccessible(true); regQueryInfoKey &#x3D; userClass.getDeclaredMethod( &quot;WindowsRegQueryInfoKey1&quot;, new Class[] &#123; int.class &#125;); regQueryInfoKey.setAccessible(true); regEnumKeyEx &#x3D; userClass.getDeclaredMethod(&quot;WindowsRegEnumKeyEx&quot;, new Class[] &#123; int.class, int.class, int.class &#125;); regEnumKeyEx.setAccessible(true); regCreateKeyEx &#x3D; userClass.getDeclaredMethod( &quot;WindowsRegCreateKeyEx&quot;, new Class[] &#123; int.class, byte[].class &#125;); regCreateKeyEx.setAccessible(true); regSetValueEx &#x3D; userClass.getDeclaredMethod(&quot;WindowsRegSetValueEx&quot;, new Class[] &#123; int.class, byte[].class, byte[].class &#125;); regSetValueEx.setAccessible(true); regDeleteValue &#x3D; userClass.getDeclaredMethod( &quot;WindowsRegDeleteValue&quot;, new Class[] &#123; int.class, byte[].class &#125;); regDeleteValue.setAccessible(true); regDeleteKey &#x3D; userClass.getDeclaredMethod(&quot;WindowsRegDeleteKey&quot;, new Class[] &#123; int.class, byte[].class &#125;); regDeleteKey.setAccessible(true); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#x2F;** * Reads value for the key from given path * * @param hkey * HKEY_CURRENT_USER&#x2F;HKEY_LOCAL_MACHINE * @param path * @param key * @return the value * @throws IllegalArgumentException * @throws IllegalAccessException * @throws InvocationTargetException * @throws IOException *&#x2F; public static String valueForKey(int hkey, String path, String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException, IOException &#123; if (hkey &#x3D;&#x3D; HKEY_LOCAL_MACHINE) return valueForKey(systemRoot, hkey, path, key); else if (hkey &#x3D;&#x3D; HKEY_CURRENT_USER) return valueForKey(userRoot, hkey, path, key); else return valueForKey(null, hkey, path, key); &#125; &#x2F;** * Reads all key(s) and value(s) from given path * * @param hkey * HKEY_CURRENT_USER&#x2F;HKEY_LOCAL_MACHINE * @param path * @return the map of key(s) and corresponding value(s) * @throws IllegalArgumentException * @throws IllegalAccessException * @throws InvocationTargetException * @throws IOException *&#x2F; public static Map&lt;String, String&gt; valuesForPath(int hkey, String path) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException, IOException &#123; if (hkey &#x3D;&#x3D; HKEY_LOCAL_MACHINE) return valuesForPath(systemRoot, hkey, path); else if (hkey &#x3D;&#x3D; HKEY_CURRENT_USER) return valuesForPath(userRoot, hkey, path); else return valuesForPath(null, hkey, path); &#125; &#x2F;** * Read all the subkey(s) from a given path * * @param hkey * HKEY_CURRENT_USER&#x2F;HKEY_LOCAL_MACHINE * @param path * @return the subkey(s) list * @throws IllegalArgumentException * @throws IllegalAccessException * @throws InvocationTargetException *&#x2F; public static List&lt;String&gt; subKeysForPath(int hkey, String path) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException &#123; if (hkey &#x3D;&#x3D; HKEY_LOCAL_MACHINE) return subKeysForPath(systemRoot, hkey, path); else if (hkey &#x3D;&#x3D; HKEY_CURRENT_USER) return subKeysForPath(userRoot, hkey, path); else return subKeysForPath(null, hkey, path); &#125; &#x2F;** * Create a key * * @param hkey * HKEY_CURRENT_USER&#x2F;HKEY_LOCAL_MACHINE * @param key * @throws IllegalArgumentException * @throws IllegalAccessException * @throws InvocationTargetException *&#x2F; public static void createKey(int hkey, String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException &#123; int[] ret; if (hkey &#x3D;&#x3D; HKEY_LOCAL_MACHINE) &#123; ret &#x3D; createKey(systemRoot, hkey, key); regCloseKey .invoke(systemRoot, new Object[] &#123; new Integer(ret[0]) &#125;); &#125; else if (hkey &#x3D;&#x3D; HKEY_CURRENT_USER) &#123; ret &#x3D; createKey(userRoot, hkey, key); regCloseKey.invoke(userRoot, new Object[] &#123; new Integer(ret[0]) &#125;); &#125; else throw new IllegalArgumentException(&quot;hkey&#x3D;&quot; + hkey); if (ret[1] !&#x3D; REG_SUCCESS) throw new IllegalArgumentException(&quot;rc&#x3D;&quot; + ret[1] + &quot; key&#x3D;&quot; + key); &#125; &#x2F;** * Write a value in a given key&#x2F;value name * * @param hkey * @param key * @param valueName * @param value * @throws IllegalArgumentException * @throws IllegalAccessException * @throws InvocationTargetException *&#x2F; public static void writeStringValue(int hkey, String key, String valueName, String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException &#123; if (hkey &#x3D;&#x3D; HKEY_LOCAL_MACHINE) writeStringValue(systemRoot, hkey, key, valueName, value); else if (hkey &#x3D;&#x3D; HKEY_CURRENT_USER) writeStringValue(userRoot, hkey, key, valueName, value); else throw new IllegalArgumentException(&quot;hkey&#x3D;&quot; + hkey); &#125; &#x2F;** * Delete a given key * * @param hkey * @param key * @throws IllegalArgumentException * @throws IllegalAccessException * @throws InvocationTargetException *&#x2F; public static void deleteKey(int hkey, String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException &#123; int rc &#x3D; -1; if (hkey &#x3D;&#x3D; HKEY_LOCAL_MACHINE) rc &#x3D; deleteKey(systemRoot, hkey, key); else if (hkey &#x3D;&#x3D; HKEY_CURRENT_USER) rc &#x3D; deleteKey(userRoot, hkey, key); if (rc !&#x3D; REG_SUCCESS) throw new IllegalArgumentException(&quot;rc&#x3D;&quot; + rc + &quot; key&#x3D;&quot; + key); &#125; &#x2F;** * delete a value from a given key&#x2F;value name * * @param hkey * @param key * @param value * @throws IllegalArgumentException * @throws IllegalAccessException * @throws InvocationTargetException *&#x2F; public static void deleteValue(int hkey, String key, String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException &#123; int rc &#x3D; -1; if (hkey &#x3D;&#x3D; HKEY_LOCAL_MACHINE) rc &#x3D; deleteValue(systemRoot, hkey, key, value); else if (hkey &#x3D;&#x3D; HKEY_CURRENT_USER) rc &#x3D; deleteValue(userRoot, hkey, key, value); if (rc !&#x3D; REG_SUCCESS) throw new IllegalArgumentException(&quot;rc&#x3D;&quot; + rc + &quot; key&#x3D;&quot; + key + &quot; value&#x3D;&quot; + value); &#125; &#x2F;&#x2F; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; private static int deleteValue(Preferences root, int hkey, String key, String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException &#123; int[] handles &#x3D; (int[]) regOpenKey.invoke(root, new Object[] &#123; new Integer(hkey), toCstr(key), new Integer(KEY_ALL_ACCESS) &#125;); if (handles[1] !&#x3D; REG_SUCCESS) return handles[1]; &#x2F;&#x2F; can be REG_NOTFOUND, REG_ACCESSDENIED int rc &#x3D; ((Integer) regDeleteValue.invoke(root, new Object[] &#123; new Integer(handles[0]), toCstr(value) &#125;)).intValue(); regCloseKey.invoke(root, new Object[] &#123; new Integer(handles[0]) &#125;); return rc; &#125; private static int deleteKey(Preferences root, int hkey, String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException &#123; int rc &#x3D; ((Integer) regDeleteKey.invoke(root, new Object[] &#123; new Integer(hkey), toCstr(key) &#125;)).intValue(); return rc; &#x2F;&#x2F; can REG_NOTFOUND, REG_ACCESSDENIED, REG_SUCCESS &#125; private static String valueForKey(Preferences root, int hkey, String path, String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException, IOException &#123; int[] handles &#x3D; (int[]) regOpenKey.invoke(root, new Object[] &#123; new Integer(hkey), toCstr(path), new Integer(KEY_READ) &#125;); if (handles[1] !&#x3D; REG_SUCCESS) throw new IllegalArgumentException( &quot;The system can not find the specified path: &#39;&quot; + getParentKey(hkey) + &quot;\\\\&quot; + path + &quot;&#39;&quot;); byte[] valb &#x3D; (byte[]) regQueryValueEx.invoke(root, new Object[] &#123; new Integer(handles[0]), toCstr(key) &#125;); regCloseKey.invoke(root, new Object[] &#123; new Integer(handles[0]) &#125;); return (valb !&#x3D; null ? parseValue(valb) : queryValueForKey(hkey, path, key)); &#125; private static String queryValueForKey(int hkey, String path, String key) throws IOException &#123; return queryValuesForPath(hkey, path).get(key); &#125; private static Map&lt;String, String&gt; valuesForPath(Preferences root, int hkey, String path) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException, IOException &#123; HashMap&lt;String, String&gt; results &#x3D; new HashMap&lt;String, String&gt;(); int[] handles &#x3D; (int[]) regOpenKey.invoke(root, new Object[] &#123; new Integer(hkey), toCstr(path), new Integer(KEY_READ) &#125;); if (handles[1] !&#x3D; REG_SUCCESS) throw new IllegalArgumentException( &quot;The system can not find the specified path: &#39;&quot; + getParentKey(hkey) + &quot;\\\\&quot; + path + &quot;&#39;&quot;); int[] info &#x3D; (int[]) regQueryInfoKey.invoke(root, new Object[] &#123; new Integer(handles[0]) &#125;); int count &#x3D; info[2]; &#x2F;&#x2F; Fixed: info[0] was being used here int maxlen &#x3D; info[4]; &#x2F;&#x2F; while info[3] was being used here, causing &#x2F;&#x2F; wrong results for (int index &#x3D; 0; index &lt; count; index++) &#123; byte[] valb &#x3D; (byte[]) regEnumValue.invoke(root, new Object[] &#123; new Integer(handles[0]), new Integer(index), new Integer(maxlen + 1) &#125;); String vald &#x3D; parseValue(valb); if (valb &#x3D;&#x3D; null || vald.isEmpty()) return queryValuesForPath(hkey, path); results.put(vald, valueForKey(root, hkey, path, vald)); &#125; regCloseKey.invoke(root, new Object[] &#123; new Integer(handles[0]) &#125;); return results; &#125; &#x2F;** * Searches recursively into the path to find the value for key. This method * gives only first occurrence value of the key. If required to get all * values in the path recursively for this key, then * &#123;@link #valuesForKeyPath(int hkey, String path, String key)&#125; should be * used. * * @param hkey * @param path * @param key * @param list * @return the value of given key obtained recursively * @throws IllegalArgumentException * @throws IllegalAccessException * @throws InvocationTargetException * @throws IOException *&#x2F; public static String valueForKeyPath(int hkey, String path, String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException, IOException &#123; String val; try &#123; val &#x3D; valuesForKeyPath(hkey, path, key).get(0); &#125; catch (IndexOutOfBoundsException e) &#123; throw new IllegalArgumentException( &quot;The system can not find the key: &#39;&quot; + key + &quot;&#39; after &quot; + &quot;searching the specified path: &#39;&quot; + getParentKey(hkey) + &quot;\\\\&quot; + path + &quot;&#39;&quot;); &#125; return val; &#125; &#x2F;** * Searches recursively into given path for particular key and stores * obtained value in list * * @param hkey * @param path * @param key * @param list * @return list containing values for given key obtained recursively * @throws IllegalArgumentException * @throws IllegalAccessException * @throws InvocationTargetException * @throws IOException *&#x2F; public static List&lt;String&gt; valuesForKeyPath(int hkey, String path, String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException, IOException &#123; List&lt;String&gt; list &#x3D; new ArrayList&lt;String&gt;(); if (hkey &#x3D;&#x3D; HKEY_LOCAL_MACHINE) return valuesForKeyPath(systemRoot, hkey, path, key, list); else if (hkey &#x3D;&#x3D; HKEY_CURRENT_USER) return valuesForKeyPath(userRoot, hkey, path, key, list); else return valuesForKeyPath(null, hkey, path, key, list); &#125; private static List&lt;String&gt; valuesForKeyPath(Preferences root, int hkey, String path, String key, List&lt;String&gt; list) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException, IOException &#123; if (!isDirectory(root, hkey, path)) &#123; takeValueInListForKey(hkey, path, key, list); &#125; else &#123; List&lt;String&gt; subKeys &#x3D; subKeysForPath(root, hkey, path); for (String subkey : subKeys) &#123; String newPath &#x3D; path + &quot;\\\\&quot; + subkey; if (isDirectory(root, hkey, newPath)) valuesForKeyPath(root, hkey, newPath, key, list); takeValueInListForKey(hkey, newPath, key, list); &#125; &#125; return list; &#125; &#x2F;** * Takes value for key in list * * @param hkey * @param path * @param key * @param list * @throws IllegalArgumentException * @throws IllegalAccessException * @throws InvocationTargetException * @throws IOException *&#x2F; private static void takeValueInListForKey(int hkey, String path, String key, List&lt;String&gt; list) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException, IOException &#123; String value &#x3D; valueForKey(hkey, path, key); if (value !&#x3D; null) list.add(value); &#125; &#x2F;** * Checks if the path has more subkeys or not * * @param root * @param hkey * @param path * @return true if path has subkeys otherwise false * @throws IllegalArgumentException * @throws IllegalAccessException * @throws InvocationTargetException *&#x2F; private static boolean isDirectory(Preferences root, int hkey, String path) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException &#123; return !subKeysForPath(root, hkey, path).isEmpty(); &#125; private static List&lt;String&gt; subKeysForPath(Preferences root, int hkey, String path) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException &#123; List&lt;String&gt; results &#x3D; new ArrayList&lt;String&gt;(); int[] handles &#x3D; (int[]) regOpenKey.invoke(root, new Object[] &#123; new Integer(hkey), toCstr(path), new Integer(KEY_READ) &#125;); if (handles[1] !&#x3D; REG_SUCCESS) throw new IllegalArgumentException( &quot;The system can not find the specified path: &#39;&quot; + getParentKey(hkey) + &quot;\\\\&quot; + path + &quot;&#39;&quot;); int[] info &#x3D; (int[]) regQueryInfoKey.invoke(root, new Object[] &#123; new Integer(handles[0]) &#125;); int count &#x3D; info[0]; &#x2F;&#x2F; Fix: info[2] was being used here with wrong &#x2F;&#x2F; results. Suggested by davenpcj, confirmed by &#x2F;&#x2F; Petrucio int maxlen &#x3D; info[3]; &#x2F;&#x2F; value length max for (int index &#x3D; 0; index &lt; count; index++) &#123; byte[] valb &#x3D; (byte[]) regEnumKeyEx.invoke(root, new Object[] &#123; new Integer(handles[0]), new Integer(index), new Integer(maxlen + 1) &#125;); results.add(parseValue(valb)); &#125; regCloseKey.invoke(root, new Object[] &#123; new Integer(handles[0]) &#125;); return results; &#125; private static int[] createKey(Preferences root, int hkey, String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException &#123; return (int[]) regCreateKeyEx.invoke(root, new Object[] &#123; new Integer(hkey), toCstr(key) &#125;); &#125; private static void writeStringValue(Preferences root, int hkey, String key, String valueName, String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException &#123; int[] handles &#x3D; (int[]) regOpenKey.invoke(root, new Object[] &#123; new Integer(hkey), toCstr(key), new Integer(KEY_ALL_ACCESS) &#125;); regSetValueEx.invoke(root, new Object[] &#123; new Integer(handles[0]), toCstr(valueName), toCstr(value) &#125;); regCloseKey.invoke(root, new Object[] &#123; new Integer(handles[0]) &#125;); &#125; &#x2F;** * Makes cmd query for the given hkey and path then executes the query * * @param hkey * @param path * @return the map containing all results in form of key(s) and value(s) * obtained by executing query * @throws IOException *&#x2F; private static Map&lt;String, String&gt; queryValuesForPath(int hkey, String path) throws IOException &#123; String line; StringBuilder builder &#x3D; new StringBuilder(); Map&lt;String, String&gt; map &#x3D; new HashMap&lt;String, String&gt;(); Process process &#x3D; Runtime.getRuntime().exec( &quot;reg query \\&quot;&quot; + getParentKey(hkey) + &quot;\\\\&quot; + path + &quot;\\&quot;&quot;); BufferedReader reader &#x3D; new BufferedReader(new InputStreamReader( process.getInputStream())); while ((line &#x3D; reader.readLine()) !&#x3D; null) &#123; if (!line.contains(&quot;REG_&quot;)) continue; StringTokenizer tokenizer &#x3D; new StringTokenizer(line, &quot; \\t&quot;); while (tokenizer.hasMoreTokens()) &#123; String token &#x3D; tokenizer.nextToken(); if (token.startsWith(&quot;REG_&quot;)) builder.append(&quot;\\t &quot;); else builder.append(token).append(&quot; &quot;); &#125; String[] arr &#x3D; builder.toString().split(&quot;\\t&quot;); map.put(arr[0].trim(), arr[1].trim()); builder.setLength(0); &#125; return map; &#125; &#x2F;** * Determines the string equivalent of hkey * * @param hkey * @return string equivalent of hkey *&#x2F; private static String getParentKey(int hkey) &#123; if (hkey &#x3D;&#x3D; HKEY_CLASSES_ROOT) return CLASSES_ROOT; else if (hkey &#x3D;&#x3D; HKEY_CURRENT_USER) return CURRENT_USER; else if (hkey &#x3D;&#x3D; HKEY_LOCAL_MACHINE) return LOCAL_MACHINE; return null; &#125; &#x2F;** * Intern method which adds the trailing \\0 for the handle with java.dll * * @param str * String * @return byte[] *&#x2F; private static byte[] toCstr(String str) &#123; if (str &#x3D;&#x3D; null) str &#x3D; &quot;&quot;; return (str +&#x3D; &quot;\\0&quot;).getBytes(); &#125; &#x2F;** * Method removes the trailing \\0 which is returned from the java.dll (just * if the last sign is a \\0) * * @param buf * the byte[] buffer which every read method returns * @return String a parsed string without the trailing \\0 *&#x2F; private static String parseValue(byte buf[]) &#123; if (buf &#x3D;&#x3D; null) return null; String ret &#x3D; new String(buf); if (ret.charAt(ret.length() - 1) &#x3D;&#x3D; &#39;\\0&#39;) return ret.substring(0, ret.length() - 1); return ret; &#125;&#125; 123456789101112131415&#x2F;&#x2F; 这个方法可以读取注册表的值，需要其他方法可自行阅读代码&#x2F;** * Reads value for the key from given path * * @param hkey * HKEY_CLASSES_ROOT&#x2F;HKEY_CURRENT_USER&#x2F;HKEY_LOCAL_MACHINE * @param path * @param key * @return the value * @throws IllegalArgumentException * @throws IllegalAccessException * @throws InvocationTargetException * @throws IOException *&#x2F;WinRegistry.valueForKey(hkey,path,key); 此时此刻，只有一张图能表达我的心情","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://poichigeon.github.io/tags/Java/"}]},{"title":"【前缀和】差分数组的使用","slug":"flight-bookings","date":"2021-08-31T01:30:00.000Z","updated":"2021-08-31T01:56:28.178Z","comments":true,"path":"2021/08/31/flight-bookings/","link":"","permalink":"https://poichigeon.github.io/2021/08/31/flight-bookings/","excerpt":"今天的每日一题，1109. 航班预订统计 看完描述，这算什么中等题，我直接开干。","text":"今天的每日一题，1109. 航班预订统计 看完描述，这算什么中等题，我直接开干。 12345678910111213class Solution &#123; public int[] corpFlightBookings(int[][] bookings, int n) &#123; int[] answer &#x3D; new int[n]; for(int i &#x3D; 1; i &lt;&#x3D; n; i++)&#123; for(int j &#x3D; 0; j &lt; bookings.length; j++)&#123; if(i&gt;&#x3D; bookings[j][0] &amp;&amp; i &lt;&#x3D; bookings[j][1])&#123; answer[i-1] +&#x3D; bookings[j][2]; &#125; &#125; &#125; return answer; &#125;&#125; 时间复杂度O(m*n)，果不其然，一个时的超。 然后稍微优化了一下 1234567891011class Solution &#123; public int[] corpFlightBookings(int[][] bookings, int n) &#123; int[] answer &#x3D; new int[n]; for(int i &#x3D; 0; i &lt; bookings.length; i++)&#123; for(int j &#x3D; bookings[i][0]; j &lt;&#x3D; bookings[i][1]; j++)&#123; answer[j-1] +&#x3D; bookings[i][2]; &#125; &#125; return answer; &#125;&#125; 这次的代码本质上也是O(m*n)的复杂度，不过比之前的小很多，还好过了，耗时1631ms，击败了9%的小伙伴。 怎会如此.jpg，就这么一个看起来普普通通的题还能玩出花来？看看题解怎么说。 … 看完题解，我是伞兵，前缀和还能这么用的吗？ 根据bookings这个数组可以得到每个航班预定座位的改变值。 再次大受震撼.jpg 放代码 1234567891011121314151617class Solution &#123; public int[] corpFlightBookings(int[][] bookings, int n) &#123; &#x2F;&#x2F; d[] 用来记录改变值 int[] d &#x3D; new int[n+1]; int[] answer &#x3D; new int[n]; for(int i &#x3D; 0; i &lt; bookings.length; i++)&#123; d[bookings[i][0]-1] +&#x3D; bookings[i][2]; d[bookings[i][1]] -&#x3D; bookings[i][2]; &#125; answer[0] &#x3D; d[0]; for( int i &#x3D; 1; i &lt; n; i++)&#123; answer[i] +&#x3D; d[i]+answer[i-1]; &#125; return answer; &#125;&#125; O(m*n)的算法就像一条一条，有条不紊的整理好每一条记录 而题解这个O(m+n)的算法，就像一巴掌把所有记录拍在一起，但结果没有问题Orz","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://poichigeon.github.io/tags/Java/"},{"name":"算法","slug":"算法","permalink":"https://poichigeon.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"【算法笔记】797. 所有可能的路径","slug":"deque-usage","date":"2021-08-25T08:21:12.000Z","updated":"2021-08-25T08:45:00.523Z","comments":true,"path":"2021/08/25/deque-usage/","link":"","permalink":"https://poichigeon.github.io/2021/08/25/deque-usage/","excerpt":"今天刷力扣的每日一题797. 所有可能的路径时，发现官方题解用到了Deque，而且用的很巧妙，我大受震撼.jpg","text":"今天刷力扣的每日一题797. 所有可能的路径时，发现官方题解用到了Deque，而且用的很巧妙，我大受震撼.jpg Deque简单来讲就是支持在头和尾进行插入和删除的数据结构，我直接搬出题解代码 1234567891011121314151617181920212223deploy:class Solution &#123; List&lt;List&lt;Integer&gt;&gt; ans &#x3D; new ArrayList&lt;List&lt;Integer&gt;&gt;(); Deque&lt;Integer&gt; stack &#x3D; new ArrayDeque&lt;Integer&gt;(); public List&lt;List&lt;Integer&gt;&gt; allPathsSourceTarget(int[][] graph) &#123; stack.offerLast(0); dfs(graph, 0, graph.length - 1); return ans; &#125; public void dfs(int[][] graph, int x, int n) &#123; if (x &#x3D;&#x3D; n) &#123; ans.add(new ArrayList&lt;Integer&gt;(stack)); &#x2F;&#x2F; new一个List出来保存路径 return; &#125; for (int y : graph[x]) &#123; stack.offerLast(y); &#x2F;&#x2F; 把目标节点放到stack里 dfs(graph, y, n); stack.pollLast(); &#x2F;&#x2F; 目标节点用完就扔，然后找下一个目标节点 &#125; &#125;&#125; 之前遇到这种需要记录路径的问题一直束手无策，今天真的茅塞顿开、恍然大悟，居然可以把节点用完就扔，只用一个Deque就能维护路径(虽然这题用栈就够用了，多了解一种数据结构总没毛病)","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://poichigeon.github.io/tags/Java/"},{"name":"算法","slug":"算法","permalink":"https://poichigeon.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"图","slug":"图","permalink":"https://poichigeon.github.io/tags/%E5%9B%BE/"}]},{"title":"【群晖NAS】qBittorrent的安装与使用","slug":"nas-qbittorrent","date":"2021-03-10T09:14:50.000Z","updated":"2021-03-12T06:46:00.644Z","comments":true,"path":"2021/03/10/nas-qbittorrent/","link":"","permalink":"https://poichigeon.github.io/2021/03/10/nas-qbittorrent/","excerpt":"24小时开机的群晖NAS是一个理想的下载平台，这不赶紧部署一个torrent下载工具。","text":"24小时开机的群晖NAS是一个理想的下载平台，这不赶紧部署一个torrent下载工具。 ¶准备工作 ¶安装Docker qBittorrent是以Docker的形式运行的，因此需要在套件中心安装Docker ¶下载qBittorrent映像 安装完成后打开Docker,在注册表中搜索qbittorrent 我曾经尝试过安装&quot;linuxserver/qbittorrent&quot;，但是遇到了一些问题，后来又尝试安装了&quot;johngong/qbittorrent&quot;，安装完成后能正常运行，因此本文以&quot;johngong/qbittorrent&quot;为例。 双击&quot;johngong/qbittorrent&quot;，等待弹出“选择标签”窗口，选择合适的版本，我的系统是64位，所以我安装了&quot;4.3.3_amd64&quot;这个版本 图形化界面下载docker映像可能速度很慢，可以sh连接NAS，执行以下命令进行下载 123sudo -i[input your password]docker pull johngong&#x2F;qbittorrent:[需要下载的标签] 例如，&quot;4.3.3_amd64&quot;这个版本的下载命令为 1docker pull johngong&#x2F;qbittorrent:4.3.3_amd64 ¶创建文件夹 在映像下载的过程中，可以创建qBittorrent需要用到的文件夹，文件夹的路径可以根据个人喜好创建 本人创建的目录如下 config文件夹用于存放配置文件，downloads文件夹用于存放下载文件。 文件夹创建之后需要进行权限配置，在qbittorrent文件夹上点击右键，选择属性 然后依次执行下图所示操作，修改文件夹权限 ¶配置qBittorrent 准备工作做完之后，就可以进行qBittorrent配置 ¶配置映像 双击下载好的qBittorrent映像 点击高级设置 在第一个签页勾选“启用自动重新启动” 在“卷”这个签页，将创建的文件夹配置进去 在端口签页，按下图所示配置端口，端口可自行决定，后续操作会用到配置的端口 最后进行环境配置，需要修改的只有WEBUIPORT这项，将其配置为端口配置中的“10000”，有关环境配置的说明可以查阅官方文档 配置完成后点击应用，然后点击下一步 在此界面查看一遍配置，确认无误后点击应用 此时在Docker的容器签页可以看到启动后的qBittorrent ¶qBittorrent的一些设置 qBittorrent已经启动，此时我们可以通过刚刚配置的WEBUIPORT访问qBittorrent的管理界面 在浏览器输入[nas的ip]:[WEBUIPORT]即可打开管理界面 管理员用户的默认用户名和密码为admin/adminadmin 登入后点击如下按钮进行设置 将下载一栏的默认保存路径配置为我们配置在“卷”中的/downloads 将连接一栏的端口配置为之前配置好的“50040” 至此，配置已经基本完成，可以通过qBittorrent进行下载了 ¶常见问题 ¶下载速度慢 原因很多，可能是做种的用户不多，也可能是TRACKER对应的资源贫乏，github上有比较热门的trackers list,可以将其中的tracker添加到qBittorrent中 ngosang_trackerslist ¶使用磁力链接下载时一直卡在“下载元数据” 可能是qBittorrent对磁力链接解析力度不够(?) 然后我的操作是把磁力链接用迅雷下载，然后开始下载后点击对应的下载，右键选择下载种子文件，此时可以将torrent下载下来，然后在qBittorrent中使用torrent文件进行下载","categories":[],"tags":[{"name":"NAS","slug":"NAS","permalink":"https://poichigeon.github.io/tags/NAS/"}]},{"title":"【hexo】指定页面不设置评论功能","slug":"page-without-comments","date":"2021-03-10T07:38:14.000Z","updated":"2021-03-10T07:44:37.919Z","comments":true,"path":"2021/03/10/page-without-comments/","link":"","permalink":"https://poichigeon.github.io/2021/03/10/page-without-comments/","excerpt":"","text":"设置了评论功能之后，在每个页面下方都会有评论模块，如何在指定页面禁用评论功能？ 只需在md文件添加如下代码 1comments: false","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://poichigeon.github.io/tags/hexo/"}]},{"title":"评论功能上线啦！","slug":"comment-published","date":"2021-03-08T07:34:49.000Z","updated":"2021-03-08T07:38:23.972Z","comments":true,"path":"2021/03/08/comment-published/","link":"","permalink":"https://poichigeon.github.io/2021/03/08/comment-published/","excerpt":"","text":"好消息，好消息！ 基于Valine和LeanCloud的评论功能上线啦，欢迎各位大佬畅所欲言！","categories":[],"tags":[]},{"title":"【hexo】deploy时unable to access ...解决(需要代理工具)","slug":"can-not-deploy","date":"2021-03-05T01:47:58.000Z","updated":"2021-03-10T07:19:04.315Z","comments":true,"path":"2021/03/05/can-not-deploy/","link":"","permalink":"https://poichigeon.github.io/2021/03/05/can-not-deploy/","excerpt":"¶情况描述 在deploy时，有时会出现如下报错，由于国内到github的连接不是很稳定，有时需要进行代理才能推送成功。","text":"¶情况描述 在deploy时，有时会出现如下报错，由于国内到github的连接不是很稳定，有时需要进行代理才能推送成功。 ¶解决方案 本人使用v2ray进行代理，可以进入设置找到本地监听端口 记下这个端口，然后进行git配置，输入如下命令 12git config --global http.proxy &#39;socks5:&#x2F;&#x2F;127.0.0.1:10808&#39;git config --global https.proxy &#39;socks5:&#x2F;&#x2F;127.0.0.1:10808&#39; 如果不再需要git走代理，可以执行以下命令取消代理 1git config --global --unset http.proxy &amp;&amp; git config --global --unset https.proxy 配置完成后，打开代理，进行deploy操作，出现如图所示结果即推送成功。","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://poichigeon.github.io/tags/hexo/"},{"name":"git","slug":"git","permalink":"https://poichigeon.github.io/tags/git/"}]},{"title":"【hexo】一个比较诡异的hexo deploy不生效原因","slug":"reason_of_deploy_failure","date":"2021-03-02T02:53:19.000Z","updated":"2021-03-10T07:23:35.758Z","comments":true,"path":"2021/03/02/reason_of_deploy_failure/","link":"","permalink":"https://poichigeon.github.io/2021/03/02/reason_of_deploy_failure/","excerpt":"¶情况描述 在lufer的指导下学习使用Hexo+Github搭建个人博客，在最后一步deploy的时候，出现这种情况，百思不得其解。","text":"¶情况描述 在lufer的指导下学习使用Hexo+Github搭建个人博客，在最后一步deploy的时候，出现这种情况，百思不得其解。 检查了deploy的配置，并没有发现问题，deploy的配置如下，空格数量也都进行了检查。 1234deploy: type: git repo: https:&#x2F;&#x2F;github.com&#x2F;Poichigeon&#x2F;Poichigeon.github.io.git branch: main 下班回家之后，又按照之前的步骤操作了一遍，这次deploy居然意外的成功了！？ 那么问题出在哪呢，掏出神器compare，进行对比，出现如下结果。 用左边的配置替换掉右边的，然后deploy居然就成功了 这就很奇怪了，难道是有什么不可见字符导致deploy不触发吗？ 打开notepad++,使用显示所有字符功能，终于抓到一点蛛丝马迹。 这个空格，竟然不一样！ 突然意识到，之前遇到的另一个报错也很莫名其妙，应该也是这个空格导致的 ¶结论 是配置中空格的问题导致deploy不生效 ¶to be continued 研究一下两种空格是如何区分的","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://poichigeon.github.io/tags/hexo/"}]},{"title":"Hello World","slug":"hello-world","date":"2021-02-25T10:12:38.418Z","updated":"2021-03-04T07:32:24.596Z","comments":true,"path":"2021/02/25/hello-world/","link":"","permalink":"https://poichigeon.github.io/2021/02/25/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. ¶Quick Start ¶Create a new post 1$ hexo new &quot;My New Post&quot; More info: Writing ¶Run server 1$ hexo server More info: Server ¶Generate static files 1$ hexo generate More info: Generating ¶Deploy to remote sites 1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"技术","slug":"技术","permalink":"https://poichigeon.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"ChatGPT","slug":"ChatGPT","permalink":"https://poichigeon.github.io/tags/ChatGPT/"},{"name":"人工智能","slug":"人工智能","permalink":"https://poichigeon.github.io/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"},{"name":"聊天机器人","slug":"聊天机器人","permalink":"https://poichigeon.github.io/tags/%E8%81%8A%E5%A4%A9%E6%9C%BA%E5%99%A8%E4%BA%BA/"},{"name":"Java","slug":"Java","permalink":"https://poichigeon.github.io/tags/Java/"},{"name":"算法","slug":"算法","permalink":"https://poichigeon.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"图","slug":"图","permalink":"https://poichigeon.github.io/tags/%E5%9B%BE/"},{"name":"NAS","slug":"NAS","permalink":"https://poichigeon.github.io/tags/NAS/"},{"name":"hexo","slug":"hexo","permalink":"https://poichigeon.github.io/tags/hexo/"},{"name":"git","slug":"git","permalink":"https://poichigeon.github.io/tags/git/"}]}